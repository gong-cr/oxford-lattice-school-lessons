\documentclass[10pt,a4paper,nobib]{tufte-handout}
%\usepackage{fontspec}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage{newunicodechar}
\usepackage[notions,operators,sets,keys,ff,adversary,primitives,complexity,asymptotics,lambda,landau,advantage]{cryptocode}
\usepackage{xspace}
\usepackage{units}
\usepackage{nicefrac}
\usepackage{gensymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[color=yellow!40]{todonotes}
%\newunicodechar{ }{~}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newtheorem{corollary}{Corollary}

%% TODO NOTES

\newcommand{\malb}[2][inline]{\todo[#1]{\textbf{malb:} #2}\xspace}


\input{lab-header-1.tex}
\author{Martin R. Albrecht, Léo Ducas and Guillaume Bonnoron}
\date{22 March 2017}
\title{Lab 1\\\medskip
\large Constructions}
\hypersetup{
pdfauthor={Martin R. Albrecht, Guillaume Bonnoron and Léo Ducas},
pdftitle={Lab 1},
pdfkeywords={},
pdfsubject={},
pdfcreator={Emacs 25.1.1 (Org mode 9.0.5)},
pdflang={English},
colorlinks,
citecolor=gray,
filecolor=gray,
linkcolor=gray,
urlcolor=gray
}
\begin{document}

\maketitle
In this lab, we will implement elementary cryptographic primitives based on lattices, namely a public-key encryption scheme\footfullcite{STOC:Regev05} in a single bit version, multi-bit version and ring version\footfullcite{EC:LyuPeiReg10}. The key take-aways will be about random sampling in lattices, security evaluation and matrix manipulations. 

% \section{Introduction}
%
% As a warm up, we ask you to play with the included \textit{Learning With Errors} oracle from Sage that we will use below to contruct the schemes.
% \lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
% \begin{lstlisting}
% sage: from sage.crypto.lwe import *
% \end{lstlisting}
%
% In this module you can find a generic LWE oracle, that allows you to choose all the parameters, together with oracles from the litterature: \texttt{Regev} or \texttt{LindnerPeikert} for example. We will first use the latter oracle
%
% \lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
% \begin{lstlisting}
% sage: R = Regev(n=16)
% sage: R
% LWE(16, 257, Discrete Gaussian sampler over the Integers with sigma =
% 1.602003 and c = 257, 'uniform', None)
% \end{lstlisting}
%
% We can see that \texttt{R} is an LWE oracle in dimension 16 with modulus 257, an discrete Gaussian error distribution of parameter 1.602003 centered in 0, a uniform secret distribution and no limit on the number of samples. Now we can call it to generate LWE samples:
%
% \lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
% \begin{lstlisting}
% sage: R2(), R2(), R2()
% (((211, 28, 215, 246, 237, 82, 72, 185, 130, 206, 34, 9, 237, 218, 245, 188),
%   236),
%  ((22, 171, 61, 96, 62, 167, 14, 241, 181, 105, 140, 199, 59, 214, 35, 174),
%   162),
%  ((244, 219, 129, 167, 13, 103, 20, 129, 174, 146, 4, 225, 214, 239, 36, 85),
%   154))
% \end{lstlisting}
%

\section{Introduction}
\label{sec:orgaad38e1}
As a warm up, we ask you to use the \textit{Discrete Gaussian Sampler} from Sage.\footfullcite{C:DDLL13} First import the necessary class:

\malb{I don't understand the citation here?}

\lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
sage: from sage.stats.distributions.discrete_gaussian_integer \
import DiscreteGaussianDistributionIntegerSampler
\end{lstlisting}

As its explicit name suggests, you can now generate lattice vectors from this sampler, providing it with the Gaussian parameter $\sigma$ of the distribution you wish to use.

\textbf{Note: } The gaussian parameter should not be mistaken with the standard deviation. A Gaussian distribution with center $c$ and parameter $\sigma$ samples elements with a probability proportional to $\exp(-\pi\frac{(x-c)^2}{\sigma^2})$.

\lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
sage: D = DiscreteGaussianDistributionIntegerSampler(sigma=2.0, c=5)
sage: D
Discrete Gaussian sampler over the Integers with sigma = 2.0 and c = 5
\end{lstlisting}

This create the sampler, that you can call to produce your integers. Here they are centered around 5, with gaussian parameter 2.

\lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
sage: D(), D(), D(), D(), D(), D()
(6, 4, 2, 6, 3, 3)
\end{lstlisting}

\malb{In Sage \(\sigma\) is the standard deviation! That sampler will have stddev 2.0.}

\subsection{Public-key Encryption --- single bit}

The public-key encryption scheme we want to implement goes as follow. Given a dimension $n$, a modulus $q$, we work in $\mathbb{Z}^n_q = (\mathbb{Z}/q\mathbb{Z})^n$. We also need a discrete Gaussian distribution of parameter $\sigma$.

\begin{itemize}
  \item \underline{ppGen:} $\mathbf{A} \in \mathbb{Z}^{n\times n}_q$ a public uniformly random matrix.
  \item \underline{KeyGen:} The public key is $\mathbf{b}^t = \mathbf{s}^t\mathbf{A} + \mathbf{e}^t \mod q$, with $\mathbf{s}, \mathbf{e} \in \mathbb{Z}^n_q$ sampled from the Gaussian distribution. The secret key is $\mathbf{s}$.
  \item \underline{Enc:} To encrypt a bit $m$, consider $\mathbf{M} = \left[ \begin{smallmatrix}
    \mathbf{A} \\
    \mathbf{b}^t
  \end{smallmatrix}\right] \in \mathbb{Z}^{(n+1)\times n}_q$ and compute
  \begin{align*}
    \mathbf{c} &= \mathbf{M}\cdot\mathbf{x} + \left(
               \begin{smallmatrix}
                 \mathbf{0} \\
                 \mu \cdot \lfloor q/2 \rceil
               \end{smallmatrix} \right)\\
               &= \left(\begin{smallmatrix}
                 \mathbf{A}\cdot \mathbf{x} \\
                 \langle \mathbf{b}\cdot \mathbf{x}\rangle
               \end{smallmatrix} \right) +
               \left( 
               \begin{smallmatrix}
                 \mathbf{0} \\
                 \mu \cdot \lfloor q/2 \rceil
               \end{smallmatrix} \right) \in \mathbb{Z}^{n+1}_q
  \end{align*}
  where $\mathbf{x}$ is uniform in $\{0, 1\}^n$.
  \item \underline{Dec:}  To decrypt, compute: 
\begin{align*}
  (-\mathbf{s}, 1)^t \cdot \mathbf{c} &= (-\mathbf{s}, 1)^t \cdot \mathbf{M} \cdot \mathbf{x} + \mu \cdot \lfloor q/2 \rceil \\
                                      &= \langle \mathbf{e}^t \cdot \mathbf{x} \rangle + \mu \cdot \lfloor q/2 \rceil \\
                                      &\approx  \mu \cdot \lfloor q/2 \rceil
\end{align*}
If this is closer to 0 than to $\lfloor q/2 \rceil$ output 0, otherwise 1. It works if $\langle \mathbf{e} \cdot \mathbf{x} \rangle < q/4$ so $q$ and $\sigma$ should be chosen accordingly.
\end{itemize}

% In 2005, Regev introduced the \textit{Learning With Errors (LWE)} problem together with a public key encryption scheme. In this part our exercice will be to implement it (we recall below the details of the scheme). We have few parameters: a dimension $n$, a modulus $q$, an error distribution $\chi$ and a number of samples $m\approx (n+1) \log q$.
%
% \begin{itemize}
% \item \textbf{KeyGen:} The secret key $\mathbf{s}$ is a uniform random element in $\mathbb{Z}^n_q = (\mathbb{Z}/q\mathbb{Z})^n$ and the public key is generated by $m$ LWE samples $(\mathbf{a}_i, b_i = \langle \mathbf{s}, \mathbf{a}_i \rangle + e_i)$. A convenient way is to contruct the matrix $\mathbf{A} \in \mathbb{Z}^{m\times(n+1)}_q$ whose rows are the $\mathbf{a}_i$ and a column vector $\mathbf{b}$ whose coefficients are the $b_i$s. The public key is then $(\mathbf{A}, \mathbf{b})$.
% \item \textbf{Enc:} To encrypt a bit $\mu$, one chooses a uniform $\mathbf{x}\in \{0, 1\}^m$ and compute $$ \mathbf{c} = (\mathbf{x}\cdot \mathbf{A}, \langle \mathbf{x}\cdot \mathbf{b}\rangle) + (\mathbf{0}, \mu \cdot \lfloor q/2 \rceil ) \in \mathbb{Z}^{n+1}_q$$
% \item \textbf{Dec:} To decrypt, one computes: 
% \begin{align*}
%   (-\mathbf{s}, 1)^t \cdot \mathbf{c} &= (-\mathbf{s}, 1)^t \cdot \mathbf{A} \cdot \mathbf{x} + \mu \cdot \lfloor q/2 \rceil \\
%                                       &= \langle \mathbf{e} \cdot \mathbf{x} \rangle + \mu \cdot \lfloor q/2 \rceil \\
%                                       &\approx  \mu \cdot \lfloor q/2 \rceil
% \end{align*}
% If this is closer to 0 than to $\lfloor q/2 \rceil$ output 0, otherwise 1. It works if $\langle \mathbf{e} \cdot \mathbf{x} \rangle < q/4$ so $q$ and $\sigma$ should be chosen accordingly.
% \end{itemize}
%
\textbf{Ex 1:} Using the Gaussian sampler from above, implement the whole scheme i.e.~the public parameter and key generations, the encryption and the decryption.

\subsection{Public-key Encryption --- multi-bit}

To improve the efficiency of the encryption scheme, it is possible to encrypt multiple bits of plaintext in one ciphertext.\footfullcite{CCS:BCDMNN16} In the single bit setting, we had for 1 bit of plaintext: $n^2$ integers of public parameter, $n$ integers of public key and of secret key, and $n+1$ integers of ciphertext. With the multibit approach, we can encrypted $k^2$ bits for only a linear expansion in the size of the keys and ciphertexts.

\malb{This is older than Frodo, no?}

The generalization of the scheme is quite straightforward. The operations remain the same, the only differences is the shift from vectors of size $n$ to matrices of dimensions $n \times k$ for $\mathbf{s}, \mathbf{e}$ and $\mathbf{b}$ and $\mathbf{x}$. Thus $\mathbf{c}$ becomes a $(n+k) \times k$ matrix where the bottom $k\times k$ coefficients store the masked encryption of $k^2$ bits $\mu_i,j$.

\textbf{Ex 2:} Adapt your previous code to handle multiple plaintext bits.

\subsection{Public-key encryption --- ring setting}

As a last improvement, we will now shift our scheme from the generic lattice setting where $\mathbf{A}$ is uniformly random in $\mathbb{Z}^{n\times n}_q$ to an ideal lattice. For this, we will work in a polynomial ring, e.g.~$R = \mathbb{Z}_q[X]/(X^n+1)$ where $n$ is a power of 2 and $q$ is prime as before.

In this setting, the scheme is adapted as follow:
\begin{itemize}
  \item \underline{ppGen:} $\mathbf{a} \in R$ a public uniformly random polynomial of $R$.
  \item \underline{KeyGen:} The public key is $\mathbf{b} = \mathbf{s} \cdot \mathbf{a} + \mathbf{e} \in R$, with $\mathbf{s}, \mathbf{e} \in R$ sampled from the Gaussian distribution. The secret key is $\mathbf{s}$.
  \item \underline{Enc:} To encrypt a binary polynomial $\mathbf{m}$, pick random $\mathbf{r}, \mathbf{e'}, \mathbf{e''} \in R$ from the Gaussian distribution and compute
$$ (\mathbf{c}_0, \mathbf{c}_1) = (\mathbf{a}\cdot\mathbf{r} + \mathbf{e'}, \mathbf{b}\cdot \mathbf{r} + \mathbf{e''} + \mathbf{m} \cdot \lfloor q/2 \rceil) $$
  \item \underline{Dec:}  To decrypt, one computes: 
\begin{align*}
   \mathbf{c}_1 - s \cdot \mathbf{c}_0 &= \mathbf{m} \cdot \lfloor q/2 \rceil + \mathbf{b}\cdot \mathbf{r} - \mathbf{s}\cdot\mathbf{a}\cdot\mathbf{r} + \mathbf{e''} - \mathbf{s}\cdot\mathbf{e'}\\
                                       &= \mathbf{m} \cdot \lfloor q/2 \rceil + \mathbf{e}\cdot \mathbf{r} + \mathbf{e''} - \mathbf{s}\cdot\mathbf{e'} \\
                                       &\approx  \mathbf{m} \cdot \lfloor q/2 \rceil
\end{align*}
So for each coefficient we apply the same rule as before, if it is closer to 0 than to $\lfloor q/2 \rceil$ output 0, otherwise 1. 
\end{itemize}

\textbf{Ex 3:} For this adaptation, more code changes are needed. You can look at the code snippet below for an idea on how to use polynomial ring in Sage and its Gaussiam Sampler over Polynomials.
\lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
from sage.stats.distributions.discrete_gaussian_polynomial \
import DiscreteGaussianDistributionPolynomialSampler
...

Zq = ZZ.quotient(q*ZZ)
Rq.<x> = Zq['x'].quotient_ring(x^n+1)
P = DiscreteGaussianDistributionPolynomialSampler(Rq, n, sigma)
P()
\end{lstlisting}

\malb{This is just a thin wrapper around the integer sampler, could also tell them to use integer sampler and cast to the polynomial ring}


\section{Security evaluation}

Now that the scheme is working and fairly efficient, the question remains of its level of security. Here we have $n$ that determines both the modulus $q$ and the Gaussian parameter $\sigma$. So we will play with $n$, and later also with $q$ and $\sigma$, and explore the level of security that we obtain.

For this work, we will use the estimator\footfullcite{EPRINT:AlbPlaSco15} that models the performance of (nearly) all existing attacks against LWE\@.

\malb{Maybe also Léo's code for comparison?}

\section{Example solutions}
\subsection{Public-key Encryption --- single bit}

\lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
from sage.stats.distributions.discrete_gaussian_integer \
import DiscreteGaussianDistributionIntegerSampler

# Init, set dimension
n = 500
q = next_prime(n^2)
sigma = sqrt(n/(2*pi.n()))
D = DiscreteGaussianDistributionIntegerSampler(sigma=sigma)
ZZq = ZZ.quotient(q*ZZ) # IntegerModRing(q) or GF(q) also work

# ppGen
A = random_matrix(ZZq, n) # I'd do random_matrix(ZZq, n, n) to be explicit, you'd also need m = 2nlog(q,2) to be secure or do the ring trick here too of adding small noise

# KeyGen
s = vector(ZZq, [D() for _ in range(n)])
e = vector(ZZq, [D() for _ in range(n)])
b = s * A + e

# Encrypt bit m
m = 1  # or 0
M = A.stack(b)
x = random_vector(n, 0, 2) # I'd do random_vector(ZZ, m, x=-1, y=2)
c = M*x 
c[n] = (c[n] + m*round(q/2)) % q # m*q//2

# Decrypt
d = list(-s)
d.append(1)
m_dec = vector(d) * c
if round(q/4) < m_dec and m_dec < round(3*q/4):
    print 1
else:
    print 0
\end{lstlisting}

\malb{I'd probably define classes}

\subsection{Public-key Encryption - multi-bit}

\lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
from sage.stats.distributions.discrete_gaussian_integer \
import DiscreteGaussianDistributionIntegerSampler

# Init, set dimension
n = 500
k = 4
q = next_prime(n^2)
sigma = sqrt(n/(2*pi.n()))
D = DiscreteGaussianDistributionIntegerSampler(sigma=sigma)
ZZq = ZZ.quotient(q*ZZ)

# ppGen
A = random_matrix(ZZq, n)

# KeyGen
s = matrix(ZZq, n, k, [D() for _ in range(n*k)])
e = matrix(ZZq, n, k, [D() for _ in range(n*k)])
b = s.transpose() * A + e.transpose()

# Encrypt k^2 bits m
m = random_matrix(ZZ, k, x=2)
print m

x = random_matrix(ZZ, n, k, x=2)
m = zero_matrix(ZZq, n, k).stack(m)
M = A.stack(b)
c = (M*x + m * round(q/2)) % q

# Decrypt
d = -s.transpose()
d = d.augment(identity_matrix(k))
m_dec = d * c

f = lambda x: 1 if round(q/4) < x and x < round(3*q/4) else 0
print m_dec.apply_map(f)

\end{lstlisting}

\subsection{Public-key encryption - ring setting}


\lstset{language=sage,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
from sage.stats.distributions.discrete_gaussian_polynomial \
import DiscreteGaussianDistributionPolynomialSampler

# Init, set dimension
n = 16
q = next_prime(n^2)
sigma = sqrt(n/(2*pi.n()))

Zq = ZZ.quotient(q*ZZ)
Rq.<x> = Zq['x'].quotient_ring(x^n+1)
P = DiscreteGaussianDistributionPolynomialSampler(Rq, n, sigma)

# ppGen
a = Rq.random_element()

# KeyGen
s = P()
e = P()
b = s * a + e

# Encrypt bit m
m = Rq([randint(0, 1) for _ in range(n)])
print m

r = P()
c = (a*r + P(), b*r + P() + Rq(m) * round(q/2))

# Decrypt
m_dec = c[1] - s * c[0]
f = lambda x: 1 if round(q/4) < x and x < round(3*q/4) else 0
print Rq(map(f, m_dec.list()))
\end{lstlisting}

\section{Security evaluation}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End:
